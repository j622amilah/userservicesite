---
title: "Chocolate bar analyses"
author: "Practicing Datsy"
date: "09-02-2023"
output: html_document
# pdf_document, word_document, Odt_document, rtf_document, md_document, github_document
---

```{r setup, include=FALSE}
 knitr::opts_chunk$set(echo = TRUE)
```

# Load packages


```{r}
installed.packages("janitor")
install.packages("party")

library(tidyverse) # metapackage of all tidyverse packages
library(magrittr)
library(janitor)
library(readr)
library(stringdist)
library(party) # RandomForest
library(tidymodels)  # train_split
library(calibrate)  # ones
library(randomForest)
library(mltools)
library(nnet)
library(neuralnet)
```


<table class="dataframe">
<caption>A matrix: 0 × 17 of type chr</caption>
<thead>
	<tr><th scope=col>Package</th><th scope=col>LibPath</th><th scope=col>Version</th><th scope=col>Priority</th><th scope=col>Depends</th><th scope=col>Imports</th><th scope=col>LinkingTo</th><th scope=col>Suggests</th><th scope=col>Enhances</th><th scope=col>License</th><th scope=col>License_is_FOSS</th><th scope=col>License_restricts_use</th><th scope=col>OS_type</th><th scope=col>Archs</th><th scope=col>MD5sum</th><th scope=col>NeedsCompilation</th><th scope=col>Built</th></tr>
</thead>
<tbody>
</tbody>
</table>



    Installing package into ‘/usr/local/lib/R/site-library’
    (as ‘lib’ is unspecified)
    


# Load the data


```{r}
path <- "/kaggle/input/chocolate-bar-ratings/flavors_of_cacao.csv"
df <- read_csv(file=path, locale=locale(encoding="latin1"))
```


# Subfunctions


```{r}
mycol_renom <- function(df, collist){
    n <- length(colnames(df))
    
    # If you do not know the names just give it an empty list so it will be named by number
    # collist <- list()
    if (length(collist) == 0){
        collist = c(1:n)
    }
    for(i in 1:n){
        colnames(df)[i] = collist[i]
    }
    return(df)
}
```


```{r}
remove_undes_dfrows <- function(df, df_col, undes_char_list){
    df_out <- data.frame()

    for (j in 1:length((rownames(df))))
    {
        c <- list()
        for (i in 1:length(undes_char_list))
        {
            wd <- paste(undes_char_list[i])
            if(df_col[j] == wd){ # exact
            #if(any(str_detect(df_num$bean_type[j], wd)) == TRUE){ # it could not remove all matches
                c <- append(c, TRUE)
            }
            else{
                c <- append(c, FALSE)
            }
        }
        if(any(c) == FALSE)
        {
            df_out <- rbind(df_out, df[j,])
        }
    }
    return(df_out)
}
```


```{r}
dfcol_2_list <- function(df_col){
    c <- list()
    for (i in 1:length(df_col)){
        c <- append(c, df_col[i])
    }
    return(c)
}
```


```{r}
lfind <- function(word, char){
    n <- nchar(char)  # length of string
    nw <- nchar(word)
    num_of_checks <- n*floor(nw/n) #(length of char)*(number of times you slide char)

    ind <- list()
    for (i in 1:num_of_checks){
        st <- i
        end <- i+n-1
        if (substr(word, st, end) == char){
            ind <- append(ind, i)
        }
    }
    return(ind)
}
```


```{r}
scaled_data_standardization <- function(feat){
        return((feat - mean(feat))/sd(feat))
}
```


```{r}
handmade_accuracy <- function(y_org, y_pred_org){
    
    n <- length(y_org)
    n_class <- length(unique(y_org))

    if (n_class == 2){
        # Binary class classification
        mydict <- get_metrics(y_org, y_pred_org)
    } else {
        # Multi-class classification
        # Re code y_org, y_pred_org as ALL OR ONE
        y <- ones(n, p=1)  # always 1 because it is the truth
        y_pred <- list()
        for (i in 1:n) {
            if (y_org[i] == y_pred_org[i]) {
                print(y_pred)
                y_pred <- append(y_pred, 1)
            } else{
                y_pred <- append(y_pred, 0)
            }
        }
        mydict <- get_metrics(y, y_pred)
    }
    return(mydict)
}
```


```{r}
get_metrics <- function(y_train, y_train_pred){
    TP_cnt <- 0
    FN_cnt <- 0
    FP_cnt <- 0
    TN_cnt <- 0
    
    n <- length(y_train)
    
    for (i in 1:n){
        if (y_train[i] == 1 & y_train_pred[i] == 1) {
            TP_cnt <- TP_cnt + 1
        } else if (y_train[i] == 0 & y_train_pred[i] == 1) {
            FN_cnt <- FN_cnt + 1
        } else if (y_train[i] == 1 & y_train_pred[i] == 0) {
            FP_cnt <- FP_cnt + 1
        } else {
            TN_cnt <- TN_cnt + 1
        }
    }
    
    mydict = {}
    mydict['precision'] <- TP_cnt/(TP_cnt + FP_cnt)
    mydict['recall'] <- TP_cnt/(TP_cnt + FN_cnt)
    mydict['acc'] <- (TP_cnt + TN_cnt)/(TP_cnt + FN_cnt + FP_cnt + TN_cnt)
    
    return(mydict)
}
```


```{r}
model_pred_accuracy_NN <- function(model, data, fst, fend, labnum){
    
    X <- data[,fst:fend]
    y_actual < data[,labnum]
    
    # ----------------------------------
    # Extract results: prediction probabilities
    # ----------------------------------
    predictions_model <- compute(model, data)
    predictions_model1 <- predictions_model$net.result
    # ----------------------------------
    
    # ----------------------------------
    # Verify predictions
    y_pred <- max.col(predictions_model1)
    # ----------------------------------
    
    # ----------------------------------
    # Put predictions in a DataFrame
    ydata <- data.frame(y_actual, y_pred, round(y_pred))
    collist <- c("y_actual", "y_pred", "y_pred_int")
    ydata <- mycol_renom(ydata, collist)

    ydata <- ydata %>%
        transform(y_actual = as.integer(y_actual), y_pred_int = as.integer(y_pred_int))
    
    # Prepare a list : the functions accuracy and handmade_accuracy need a list
    y_actual <- ydata$y_actual
    y_pred_int <- ydata$y_pred_int
    # ----------------------------------
    
    # ----------------------------------
    # Accuracy calculation
    print('Accuracy: (TP+TN)/(TP+TN+FP+FN)')
    print(mean(y_pred == y_actual))
    
    # Handmande function
    print('Accuracy: (TP+TN)/(TP+TN+FP+FN)')
    mydict <- handmade_accuracy(y_actual, y_pred_int)
    # ----------------------------------
    return(mydict)
}
```


```{r}
model_pred_accuracy_RF <- function(model, data, fst, fend, labnum){
    
    X <- data[,fst:fend]
    y_actual < data[,labnum]
    
    # ----------------------------------
    # Extract results: prediction probabilities
    # ----------------------------------
    # Works for RandomForest classification, NOT regression
    # predictions_model1 <- predict(model, data, "prob")
    # ----------------------------------
    
    # ----------------------------------
    # Verify predictions
    y_pred <- predict(model, X)
    # ----------------------------------
    
    # ----------------------------------
    # Put predictions in a DataFrame
    ydata <- data.frame(y_actual, y_pred, round(y_pred))
    collist <- c("y_actual", "y_pred", "y_pred_int")
    ydata <- mycol_renom(ydata, collist)

    ydata <- ydata %>%
        transform(y_actual = as.integer(y_actual), y_pred_int = as.integer(y_pred_int))
    
    # Prepare a list : the functions accuracy and handmade_accuracy need a list
    y_actual <- ydata$y_actual
    y_pred_int <- ydata$y_pred_int
    # ----------------------------------
    
    # ----------------------------------
    # Accuracy calculation
    print('Accuracy: (TP+TN)/(TP+TN+FP+FN)')
    print(mean(y_pred == y_actual))
    # Handmande function
    print('Accuracy: (TP+TN)/(TP+TN+FP+FN)')
    mydict <- handmade_accuracy(y_actual, y_pred_int)
    # ----------------------------------
    return(mydict)
}
```

# Pre-processing

## Search for undesired characters in bean_type


```{r}
# Look at existing column names
print('Existing column names:')
print(colnames(df))

print('------------------------------------------------------')
collist <- c("company_name", "origin_bar", "ref", "review_date", "cocoa_per", "company_loc", "rating", "bean_type","bean_origin")
df <- mycol_renom(df, collist)

print('------------------------------------------------------')
print('Changed column names:')
print(colnames(df))
```

    [1] "Existing column names:"
    [1] "CompanyÂ \n(Maker-if known)"       "Specific Bean Origin\nor Bar Name"
    [3] "REF"                               "Review\nDate" 
    [5] "Cocoa\nPercent"                    "Company\nLocation" 
    [7] "Rating"                            "Bean\nType"
    [9] "Broad Bean\nOrigin"
    [1] "------------------------------------------------------"
    [1] "------------------------------------------------------"
    [1] "Changed column names:"
    [1] "company_name" "origin_bar"   "ref"          "review_date"  "cocoa_per"
    [6] "company_loc"  "rating"       "bean_type"    "bean_origin" 



```{r}
df_num <- drop_na(df)
cocoa_per_int <- data.frame(as.double(gsub('%','',df_num$cocoa_per)))
#cocoa_per_int <- as.numeric(cocoa_per_int)

# Select numeric columns first, then categorical columns
# ref(3), cocoa_per_int(5), rating(7), bean_type(8), company_name(1), origin_bar(2), company_loc(6), bean_origin(9)
df_num <- data.frame(df_num[,3], cocoa_per_int, df_num[,7], df_num[,8], df_num[,1], df_num[,2], df_num[,6], df_num[,9])

# Rename columns
collist <- c("ref", "cocoa_per_int", "rating", "bean_type", "company_name", "origin_bar", "company_loc", "bean_origin")
df_num <- mycol_renom(df_num, collist)
```


```{r}
head(df_num)
```


<table class="dataframe">
<caption>A data.frame: 6 × 8</caption>
<thead>
	<tr><th></th><th scope=col>ref</th><th scope=col>cocoa_per_int</th><th scope=col>rating</th><th scope=col>bean_type</th><th scope=col>company_name</th><th scope=col>origin_bar</th><th scope=col>company_loc</th><th scope=col>bean_origin</th></tr>
	<tr><th></th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th></tr>
</thead>
<tbody>
	<tr><th scope=row>1</th><td>1876</td><td>63</td><td>3.75</td><td>Â      </td><td>A. Morin</td><td>Agua Grande</td><td>France</td><td>Sao Tome </td></tr>
	<tr><th scope=row>2</th><td>1676</td><td>70</td><td>2.75</td><td>Â      </td><td>A. Morin</td><td>Kpime      </td><td>France</td><td>Togo     </td></tr>
	<tr><th scope=row>3</th><td>1676</td><td>70</td><td>3.00</td><td>Â      </td><td>A. Morin</td><td>Atsane     </td><td>France</td><td>Togo     </td></tr>
	<tr><th scope=row>4</th><td>1680</td><td>70</td><td>3.50</td><td>Â      </td><td>A. Morin</td><td>Akata      </td><td>France</td><td>Togo     </td></tr>
	<tr><th scope=row>5</th><td>1704</td><td>70</td><td>3.50</td><td>Â      </td><td>A. Morin</td><td>Quilla     </td><td>France</td><td>Peru     </td></tr>
	<tr><th scope=row>6</th><td>1315</td><td>70</td><td>2.75</td><td>Criollo</td><td>A. Morin</td><td>Carenero   </td><td>France</td><td>Venezuela</td></tr>
</tbody>
</table>




```{r}
a0 <- count(df_num, bean_type, sort = TRUE)
print('a0:')
print(a0)
```

    [1] "a0:"
                      bean_type   n
    1                        Â  887
    2                Trinitario 418
    3                   Criollo 153
    4                 Forastero  87
    5      Forastero (Nacional)  52
    6                     Blend  41
    7       Criollo, Trinitario  39
    8        Forastero (Arriba)  37
    9       Criollo (Porcelana)  10
    10      Trinitario, Criollo   9
    11    Forastero (Parazinho)   8
    12   Forastero (Arriba) ASS   6
    13                  Beniano   3
    14                      EET   3
    15                   Matina   3
    16        Nacional (Arriba)   3
    17               Amazon mix   2
    18              Amazon, ICS   2
    19         Criollo (Amarru)   2
    20     Criollo (Ocumare 61)   2
    21       Criollo, Forastero   2
    22      Forastero (Catongo)   2
    23                 Nacional   2
    24 Trinitario (85% Criollo)   2
    25    Trinitario, Forastero   2
    26                   Amazon   1
    27  Blend-Forastero,Criollo   1
    28                    CCN51   1
    29     Criollo (Ocumare 67)   1
    30     Criollo (Ocumare 77)   1
    31        Criollo (Ocumare)   1
    32           Criollo (Wild)   1
    33               Criollo, +   1
    34    Forastero (Amelonado)   1
    35  Forastero (Arriba) ASSS   1
    36    Forastero, Trinitario   1
    37   Forastero(Arriba, CCN)   1
    38   Trinitario (Amelonado)   1
    39     Trinitario (Scavina)   1
    40     Trinitario, Nacional   1
    41         Trinitario, TCGA   1



```{r}
# Columns that we want to remove: too low and high counts
undes_char <- filter(a0, n < 10 | n > 450)
undes_char_list <- undes_char$bean_type
print('undes_char_list: ')
print(undes_char_list)
```

    [1] "undes_char_list: "
     [1] "Â "                       "Trinitario, Criollo" 
     [3] "Forastero (Parazinho)"    "Forastero (Arriba) ASS"
     [5] "Beniano"                  "EET" 
     [7] "Matina"                   "Nacional (Arriba)" 
     [9] "Amazon mix"               "Amazon, ICS"
    [11] "Criollo (Amarru)"         "Criollo (Ocumare 61)" 
    [13] "Criollo, Forastero"       "Forastero (Catongo)" 
    [15] "Nacional"                 "Trinitario (85% Criollo)"
    [17] "Trinitario, Forastero"    "Amazon"
    [19] "Blend-Forastero,Criollo"  "CCN51"
    [21] "Criollo (Ocumare 67)"     "Criollo (Ocumare 77)" 
    [23] "Criollo (Ocumare)"        "Criollo (Wild)" 
    [25] "Criollo, +"               "Forastero (Amelonado)" 
    [27] "Forastero (Arriba) ASSS"  "Forastero, Trinitario" 
    [29] "Forastero(Arriba, CCN)"   "Trinitario (Amelonado)"
    [31] "Trinitario (Scavina)"     "Trinitario, Nacional" 
    [33] "Trinitario, TCGA"


## Remove rows with undesired bean_type names 


```{r}
df_num2 <- remove_undes_dfrows(df_num, df_num$bean_type, undes_char_list)
```

## Reduce bean_types that have similar names


```{r}
head(df_num2)
```


<table class="dataframe">
<caption>A data.frame: 6 × 8</caption>
<thead>
	<tr><th></th><th scope=col>ref</th><th scope=col>cocoa_per_int</th><th scope=col>rating</th><th scope=col>bean_type</th><th scope=col>company_name</th><th scope=col>origin_bar</th><th scope=col>company_loc</th><th scope=col>bean_origin</th></tr>
	<tr><th></th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th></tr>
</thead>
<tbody>
	<tr><th scope=row>6</th><td>1315</td><td>70</td><td>2.75</td><td>Criollo   </td><td>A. Morin</td><td>Carenero         </td><td>France</td><td>Venezuela </td></tr>
	<tr><th scope=row>8</th><td>1315</td><td>70</td><td>3.50</td><td>Criollo   </td><td>A. Morin</td><td>Sur del Lago     </td><td>France</td><td>Venezuela </td></tr>
	<tr><th scope=row>9</th><td>1319</td><td>70</td><td>3.75</td><td>Criollo   </td><td>A. Morin</td><td>Puerto Cabello   </td><td>France</td><td>Venezuela </td></tr>
	<tr><th scope=row>12</th><td>1011</td><td>70</td><td>3.00</td><td>Criollo   </td><td>A. Morin</td><td>Madagascar       </td><td>France</td><td>Madagascar</td></tr>
	<tr><th scope=row>18</th><td>1015</td><td>70</td><td>4.00</td><td>Trinitario</td><td>A. Morin</td><td>Chuao            </td><td>France</td><td>Venezuela </td></tr>
	<tr><th scope=row>25</th><td>1470</td><td>70</td><td>3.75</td><td>Criollo   </td><td>Acalli  </td><td>Tumbes, Norandino</td><td>U.S.A.</td><td>Peru      </td></tr>
</tbody>
</table>




```{r}
a1 <- count(df_num2, bean_type, sort = TRUE)
unique_words <- dfcol_2_list(a1$bean_type)

#collist <- list()
#df_new2 <- data.frame()
for (i in 1:length(unique_words)){
    #row_vec <- list()

    word <- toString(unique_words[i])

    for (j in 1:length(unique_words)){
        #row_vec <- append(row_vec, j)
        char0 <- toString(unique_words[j])
        # OU
        # look for half of the begining words; to catch similar words
        char <- substr(char0, 1, floor(nchar(char0)/2))

        # word char match
        match_ind <- lfind(word, char)

        # Was there a match found?
        if (length(match_ind) == 0){
            bool_match <- 0
        }
        else{
            bool_match <- 1
            if (word != char0)
            {
                # determine which word should be replaced by the other 
                k <- which.min(c(nchar(word), nchar(char0)))
                if (k == 1){
                    # replace short_nom_list[j] with short_nom_list[i]
                    word2replace <- word
                    replacewith <- char0
                }
                else{
                    word2replace <- char0
                    replacewith <- word
                }
                df_num2 <- df_num2 %>%
                    mutate(bean_type=replace(bean_type, bean_type==replacewith, word2replace))
            }
        }
        #row_vec <- append(row_vec, bool_match)
    }
    #n <- length(row_vec)
    #mat <- matrix(row_vec, nrow = 1, ncol = n, byrow = 1)
    #df_temp <- as.data.frame(mat)
    #mycol_renom(df_temp, collist) # define row names
    #df_new2 <- rbind(df_new2, df_temp)
}
#mycol_renom(df_new2, collist)
```


```{r}
unique(df_num2$bean_type)
```


<style>
.list-inline {list-style: none; margin:0; padding: 0}
.list-inline>li {display: inline-block}
.list-inline>li:not(:last-child)::after {content: "\00b7"; padding: 0 .5ex}
</style>
<ol class=list-inline><li>'Criollo'</li><li>'Trinitario'</li><li>'Forastero'</li><li>'Blend'</li></ol>



## Transform categorical features to numerical values


```{r}
df_num3 <- df_num2 %>%
    mutate(bean_type_num=unclass(as.factor(bean_type)), company_name_num=unclass(as.factor(company_name)), origin_bar_num=unclass(as.factor(origin_bar)), company_loc_num=unclass(as.factor(company_loc)), bean_origin_num=unclass(as.factor(bean_origin)))

```


```{r}
print(length(rownames(df_num3)))
head(df_num3)
```

    [1] 837



<table class="dataframe">
<caption>A data.frame: 6 × 13</caption>
<thead>
	<tr><th></th><th scope=col>ref</th><th scope=col>cocoa_per_int</th><th scope=col>rating</th><th scope=col>bean_type</th><th scope=col>company_name</th><th scope=col>origin_bar</th><th scope=col>company_loc</th><th scope=col>bean_origin</th><th scope=col>bean_type_num</th><th scope=col>company_name_num</th><th scope=col>origin_bar_num</th><th scope=col>company_loc_num</th><th scope=col>bean_origin_num</th></tr>
	<tr><th></th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;chr&gt;</th><th scope=col>&lt;int&gt;</th><th scope=col>&lt;int&gt;</th><th scope=col>&lt;int&gt;</th><th scope=col>&lt;int&gt;</th><th scope=col>&lt;int&gt;</th></tr>
</thead>
<tbody>
	<tr><th scope=row>6</th><td>1315</td><td>70</td><td>2.75</td><td>Criollo   </td><td>A. Morin</td><td>Carenero         </td><td>France</td><td>Venezuela </td><td>2</td><td>1</td><td> 78</td><td>15</td><td>59</td></tr>
	<tr><th scope=row>8</th><td>1315</td><td>70</td><td>3.50</td><td>Criollo   </td><td>A. Morin</td><td>Sur del Lago     </td><td>France</td><td>Venezuela </td><td>2</td><td>1</td><td>440</td><td>15</td><td>59</td></tr>
	<tr><th scope=row>9</th><td>1319</td><td>70</td><td>3.75</td><td>Criollo   </td><td>A. Morin</td><td>Puerto Cabello   </td><td>France</td><td>Venezuela </td><td>2</td><td>1</td><td>376</td><td>15</td><td>59</td></tr>
	<tr><th scope=row>12</th><td>1011</td><td>70</td><td>3.00</td><td>Criollo   </td><td>A. Morin</td><td>Madagascar       </td><td>France</td><td>Madagascar</td><td>2</td><td>1</td><td>253</td><td>15</td><td>32</td></tr>
	<tr><th scope=row>18</th><td>1015</td><td>70</td><td>4.00</td><td>Trinitario</td><td>A. Morin</td><td>Chuao            </td><td>France</td><td>Venezuela </td><td>4</td><td>1</td><td> 93</td><td>15</td><td>59</td></tr>
	<tr><th scope=row>25</th><td>1470</td><td>70</td><td>3.75</td><td>Criollo   </td><td>Acalli  </td><td>Tumbes, Norandino</td><td>U.S.A.</td><td>Peru      </td><td>2</td><td>2</td><td>479</td><td>46</td><td>38</td></tr>
</tbody>
</table>



# CLASSIFICATION in R!! 

## Can we predict bean type using cocoa_per, REF, Rating?


```{r}
# X matrix ONLY because we need to scale X below
df_numerical <- data.frame(df_num3[,1:3])
# ref(1),  cocoa_per_int(2), rating(3)

# Rename columns
collist <- c("ref", "cocoa_per_int", "rating")
df_numerical <- mycol_renom(df_numerical, collist)

fst <- 1
fend <- 3
labnum <- 4
```


```{r}
df_numerical <- data.frame(df_num3[,1:3], df_num3[,10:13])
# ref(1),  cocoa_per_int(2), rating(3), 
# company_name_num(10), origin_bar_num(11), company_loc_num(12), bean_origin_num(13)

# Rename columns
collist <- c("ref", "cocoa_per_int", "rating", "company_name_num", "origin_bar_num", "company_loc_num", "bean_origin_num")
df_numerical <- mycol_renom(df_numerical, collist)

fst <- 1
fend <- 7
labnum <- 8
```


```{r}
#df_numerical <- as.double(df_numerical)
df_numerical <- as.data.frame(lapply(df_numerical, as.double))

print(length(rownames(df_numerical)))
head(df_numerical)
```

    [1] 837



<table class="dataframe">
<caption>A data.frame: 6 × 7</caption>
<thead>
	<tr><th></th><th scope=col>ref</th><th scope=col>cocoa_per_int</th><th scope=col>rating</th><th scope=col>company_name_num</th><th scope=col>origin_bar_num</th><th scope=col>company_loc_num</th><th scope=col>bean_origin_num</th></tr>
	<tr><th></th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th></tr>
</thead>
<tbody>
	<tr><th scope=row>1</th><td>1315</td><td>70</td><td>2.75</td><td>1</td><td> 78</td><td>15</td><td>59</td></tr>
	<tr><th scope=row>2</th><td>1315</td><td>70</td><td>3.50</td><td>1</td><td>440</td><td>15</td><td>59</td></tr>
	<tr><th scope=row>3</th><td>1319</td><td>70</td><td>3.75</td><td>1</td><td>376</td><td>15</td><td>59</td></tr>
	<tr><th scope=row>4</th><td>1011</td><td>70</td><td>3.00</td><td>1</td><td>253</td><td>15</td><td>32</td></tr>
	<tr><th scope=row>5</th><td>1015</td><td>70</td><td>4.00</td><td>1</td><td> 93</td><td>15</td><td>59</td></tr>
	<tr><th scope=row>6</th><td>1470</td><td>70</td><td>3.75</td><td>2</td><td>479</td><td>46</td><td>38</td></tr>
</tbody>
</table>



## Normalize/scale data


```{r}
# df_numerical2 <- as.data.frame(lapply(df_numerical, scaled_data_standardization))
# OR
df_numerical2 <- map_df(df_numerical,.f=scaled_data_standardization)

print(length(rownames(df_numerical2)))
head(df_numerical2)
```

    [1] 837



<table class="dataframe">
<caption>A tibble: 6 × 7</caption>
<thead>
	<tr><th scope=col>ref</th><th scope=col>cocoa_per_int</th><th scope=col>rating</th><th scope=col>company_name_num</th><th scope=col>origin_bar_num</th><th scope=col>company_loc_num</th><th scope=col>bean_origin_num</th></tr>
	<tr><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th></tr>
</thead>
<tbody>
	<tr><td>0.6948652</td><td>-0.3178854</td><td>-1.0100499</td><td>-1.724183</td><td>-1.240516349</td><td>-0.8937676</td><td> 1.32664362</td></tr>
	<tr><td>0.6948652</td><td>-0.3178854</td><td> 0.5921202</td><td>-1.724183</td><td> 1.313063038</td><td>-0.8937676</td><td> 1.32664362</td></tr>
	<tr><td>0.7019690</td><td>-0.3178854</td><td> 1.1261769</td><td>-1.724183</td><td> 0.861601489</td><td>-0.8937676</td><td> 1.32664362</td></tr>
	<tr><td>0.1549716</td><td>-0.3178854</td><td>-0.4759932</td><td>-1.724183</td><td>-0.006051176</td><td>-0.8937676</td><td>-0.08601336</td></tr>
	<tr><td>0.1620754</td><td>-0.3178854</td><td> 1.6602336</td><td>-1.724183</td><td>-1.134705048</td><td>-0.8937676</td><td> 1.32664362</td></tr>
	<tr><td>0.9701399</td><td>-0.3178854</td><td> 1.1261769</td><td>-1.711326</td><td> 1.588172419</td><td> 0.9574807</td><td> 0.22791041</td></tr>
</tbody>
</table>



### Unfornately column cocoa_per_int always becomes NA after scaling the data, I tried many transformation to try to keep it as a number. Despite the fact that I think it is an important column for prediction of bean_type, I dropped it to continue with the analysis.


```{r}
df_numerical2 <- df_numerical2[,-2]

print(length(rownames(df_numerical2)))
head(df_numerical2)
```

    [1] 837



<table class="dataframe">
<caption>A tibble: 6 × 6</caption>
<thead>
	<tr><th scope=col>ref</th><th scope=col>rating</th><th scope=col>company_name_num</th><th scope=col>origin_bar_num</th><th scope=col>company_loc_num</th><th scope=col>bean_origin_num</th></tr>
	<tr><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th></tr>
</thead>
<tbody>
	<tr><td>0.6948652</td><td>-1.0100499</td><td>-1.724183</td><td>-1.240516349</td><td>-0.8937676</td><td> 1.32664362</td></tr>
	<tr><td>0.6948652</td><td> 0.5921202</td><td>-1.724183</td><td> 1.313063038</td><td>-0.8937676</td><td> 1.32664362</td></tr>
	<tr><td>0.7019690</td><td> 1.1261769</td><td>-1.724183</td><td> 0.861601489</td><td>-0.8937676</td><td> 1.32664362</td></tr>
	<tr><td>0.1549716</td><td>-0.4759932</td><td>-1.724183</td><td>-0.006051176</td><td>-0.8937676</td><td>-0.08601336</td></tr>
	<tr><td>0.1620754</td><td> 1.6602336</td><td>-1.724183</td><td>-1.134705048</td><td>-0.8937676</td><td> 1.32664362</td></tr>
	<tr><td>0.9701399</td><td> 1.1261769</td><td>-1.711326</td><td> 1.588172419</td><td> 0.9574807</td><td> 0.22791041</td></tr>
</tbody>
</table>



## Add y to the scaled X matrix


```{r}
df_numerical3 <- data.frame(df_numerical2, df_num3[,9])
df_numerical3 <- drop_na(df_numerical3)

# Rename columns
collist <- c("ref", "rating", "company_name_num", "origin_bar_num", "company_loc_num", "bean_origin_num", "bean_type_num")
df_numerical3 <- mycol_renom(df_numerical3, collist)

print(length(rownames(df_numerical3)))
head(df_numerical3)
```

    [1] 837



<table class="dataframe">
<caption>A data.frame: 6 × 7</caption>
<thead>
	<tr><th></th><th scope=col>ref</th><th scope=col>rating</th><th scope=col>company_name_num</th><th scope=col>origin_bar_num</th><th scope=col>company_loc_num</th><th scope=col>bean_origin_num</th><th scope=col>bean_type_num</th></tr>
	<tr><th></th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;int&gt;</th></tr>
</thead>
<tbody>
	<tr><th scope=row>1</th><td>0.6948652</td><td>-1.0100499</td><td>-1.724183</td><td>-1.240516349</td><td>-0.8937676</td><td> 1.32664362</td><td>2</td></tr>
	<tr><th scope=row>2</th><td>0.6948652</td><td> 0.5921202</td><td>-1.724183</td><td> 1.313063038</td><td>-0.8937676</td><td> 1.32664362</td><td>2</td></tr>
	<tr><th scope=row>3</th><td>0.7019690</td><td> 1.1261769</td><td>-1.724183</td><td> 0.861601489</td><td>-0.8937676</td><td> 1.32664362</td><td>2</td></tr>
	<tr><th scope=row>4</th><td>0.1549716</td><td>-0.4759932</td><td>-1.724183</td><td>-0.006051176</td><td>-0.8937676</td><td>-0.08601336</td><td>2</td></tr>
	<tr><th scope=row>5</th><td>0.1620754</td><td> 1.6602336</td><td>-1.724183</td><td>-1.134705048</td><td>-0.8937676</td><td> 1.32664362</td><td>4</td></tr>
	<tr><th scope=row>6</th><td>0.9701399</td><td> 1.1261769</td><td>-1.711326</td><td> 1.588172419</td><td> 0.9574807</td><td> 0.22791041</td><td>2</td></tr>
</tbody>
</table>



## Split into train and test data set

### Since the pipe (%>%) character stopped functioning, we can not use the select() function. Thus, we need to select each column in the DataFrame by number; I use the variables fst, fend, and labnum.


```{r}
matrix_split <- initial_split(df_numerical3, prop = 3/4,)

train_data <- training(matrix_split)
test_data <- testing(matrix_split)

fst <- 1
fend <- 6
labnum <- 7

which_way = 0
if (which_way == 0){
    X_train <- train_data[,fst:fend]
    y_train <- data.frame(train_data[,labnum])
    collist <- c("bean_type_num")
    y_train <- mycol_renom(y_train, collist)
    
    X_test <- test_data[,fst:fend]
    y_test <- data.frame(test_data[,labnum])
    y_test <- mycol_renom(y_test, collist)
} else {
    X_train <- train_data %>% select(ref, cocoa_per_int, rating)
    y_train <- train_data %>% select(bean_type_num)
    X_test <- test_data %>% select(ref, cocoa_per_int, rating)
    y_test <- test_data %>% select(bean_type_num)
}
```


```{r}
print(c(length(rownames(X_train)), length(colnames(X_train))))
print(c(length(rownames(y_train)), length(colnames(y_train))))
print(c(length(rownames(X_test)), length(colnames(X_test))))
print(c(length(rownames(y_test)), length(colnames(y_test))))

print(any(is.na(X_train)))
print(any(is.na(y_train)))
print(any(is.na(X_test)))
print(any(is.na(y_test)))

print(colnames(X_train))
print(colnames(y_train))
print(colnames(X_test))
print(colnames(y_test))
```

    [1] 627   6
    [1] 627   1
    [1] 210   6
    [1] 210   1
    [1] FALSE
    [1] FALSE
    [1] FALSE
    [1] FALSE
    [1] "ref"              "rating"           "company_name_num" "origin_bar_num"
    [5] "company_loc_num"  "bean_origin_num" 
    [1] "bean_type_num"
    [1] "ref"              "rating"           "company_name_num" "origin_bar_num"
    [5] "company_loc_num"  "bean_origin_num" 
    [1] "bean_type_num"


## One-hot nototion (optional)


```{r}
y_train_onehot <- mutate(y_train, btn1 = ifelse(bean_type_num==1, 1, 0))
y_train_onehot <- mutate(y_train_onehot, btn2 = ifelse(bean_type_num==2, 1, 0))
y_train_onehot <- mutate(y_train_onehot, btn3 = ifelse(bean_type_num==3, 1, 0))
y_train_onehot <- mutate(y_train_onehot, btn4 = ifelse(bean_type_num==4, 1, 0))
y_train_onehot <- y_train_onehot[2:5]  # one-hot
```


```{r}
head(y_train_onehot)
```


<table class="dataframe">
<caption>A data.frame: 6 × 4</caption>
<thead>
	<tr><th></th><th scope=col>btn1</th><th scope=col>btn2</th><th scope=col>btn3</th><th scope=col>btn4</th></tr>
	<tr><th></th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th></tr>
</thead>
<tbody>
	<tr><th scope=row>1</th><td>0</td><td>0</td><td>0</td><td>1</td></tr>
	<tr><th scope=row>2</th><td>0</td><td>0</td><td>1</td><td>0</td></tr>
	<tr><th scope=row>3</th><td>0</td><td>0</td><td>0</td><td>1</td></tr>
	<tr><th scope=row>4</th><td>0</td><td>0</td><td>0</td><td>1</td></tr>
	<tr><th scope=row>5</th><td>0</td><td>0</td><td>0</td><td>1</td></tr>
	<tr><th scope=row>6</th><td>0</td><td>0</td><td>0</td><td>1</td></tr>
</tbody>
</table>




```{r}
y_test_onehot <- mutate(y_test, btn1 = ifelse(bean_type_num==1, 1, 0))
y_test_onehot <- mutate(y_test_onehot, btn2 = ifelse(bean_type_num==2, 1, 0))
y_test_onehot <- mutate(y_test_onehot, btn3 = ifelse(bean_type_num==3, 1, 0))
y_test_onehot <- mutate(y_test_onehot, btn4 = ifelse(bean_type_num==4, 1, 0))
y_test_onehot <- y_test_onehot[2:5]  # one-hot
```


```{r}
head(y_test_onehot)
```


<table class="dataframe">
<caption>A data.frame: 6 × 4</caption>
<thead>
	<tr><th></th><th scope=col>btn1</th><th scope=col>btn2</th><th scope=col>btn3</th><th scope=col>btn4</th></tr>
	<tr><th></th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th><th scope=col>&lt;dbl&gt;</th></tr>
</thead>
<tbody>
	<tr><th scope=row>1</th><td>0</td><td>1</td><td>0</td><td>0</td></tr>
	<tr><th scope=row>2</th><td>0</td><td>1</td><td>0</td><td>0</td></tr>
	<tr><th scope=row>3</th><td>0</td><td>0</td><td>0</td><td>1</td></tr>
	<tr><th scope=row>4</th><td>0</td><td>0</td><td>0</td><td>1</td></tr>
	<tr><th scope=row>5</th><td>0</td><td>0</td><td>0</td><td>1</td></tr>
	<tr><th scope=row>6</th><td>0</td><td>0</td><td>0</td><td>1</td></tr>
</tbody>
</table>




```{r}
print(c(length(rownames(X_train)), length(colnames(X_train))))
print(c(length(rownames(y_train_onehot)), length(colnames(y_train_onehot))))
print(c(length(rownames(X_test)), length(colnames(X_test))))
print(c(length(rownames(y_test_onehot)), length(colnames(y_test_onehot))))

print(any(is.na(X_train)))
print(any(is.na(y_train_onehot)))
print(any(is.na(X_test)))
print(any(is.na(y_test_onehot)))

print(colnames(X_train))
print(colnames(y_train_onehot))
print(colnames(X_test))
print(colnames(y_test_onehot))
```

    [1] 627   6
    [1] 627   4
    [1] 210   6
    [1] 210   4
    [1] FALSE
    [1] FALSE
    [1] FALSE
    [1] FALSE
    [1] "ref"              "rating"           "company_name_num" "origin_bar_num"
    [5] "company_loc_num"  "bean_origin_num" 
    [1] "btn1" "btn2" "btn3" "btn4"
    [1] "ref"              "rating"           "company_name_num" "origin_bar_num"
    [5] "company_loc_num"  "bean_origin_num" 
    [1] "btn1" "btn2" "btn3" "btn4"


# Neural Network


```{r}
# Covariates/features with response/y, but it ignores response/y column/s 
# because you specify which column/s are y
data_train <- data.frame(X_train, y_train) 
data_train_onehot <- data.frame(X_train, y_train_onehot)
data_test <- data.frame(X_test, y_test) 
data_test_onehot <- data.frame(X_test, y_test_onehot)

laquelle = 4

if (laquelle == 0){
    # Regression: nnet model: DataFrame y vector notation
    y <- y_train # response
    model <- nnet(formula=y ~ ., data=X_train, size = 30)
    # OR
    # model <- nnet(formula=y_train[,1] ~ ., data=X_train, size = 30)
    # ..........
    data <- X_train
    y_actual <- y_train
    
} else if (laquelle == 1) {
    # Classification: nnet model: String one-hot notation
    X <- c("ref","cocoa_per_int","rating")  # covariates/features
    y <- 'btn1 + btn2 + btn3 + btn4 ~ ' # response
    f <- as.formula(paste(y , paste(X, collapse='+')))
    print(f)
    model <- nnet(formula=f, data=data_train_onehot, size = 30)
    # ..........
    data <- data_train_onehot
    y_actual <- y_train_onehot
    
} else if (laquelle == 2) {
    # Classification: neuralnet model: String one-hot notation
    X <- c("ref","cocoa_per_int","rating")  # covariates/features
    y <- 'btn1 + btn2 + btn3 + btn4 ~ ' # response
    f <- as.formula(paste(y , paste(X, collapse='+')))
    print(f)
    model <- neuralnet(f, data=data_train_onehot, hidden = c(9, 3, 4),
                       act.fct = "logistic", linear.output = FALSE, lifesign = "minimal")
    # response = btn1 btn2 btn3 btn4
    # covariate = ref cocoa_per_int rating
    # data = ref cocoa_per_int rating btn1 btn2 btn3 btn4
    # linear.output = FALSE such that you can specify a cost function (ie: logistic, relu, tanh)
    # ..........
    data <- data_train_onehot
    y_actual <- y_train_onehot
    
} else if (laquelle == 3) {
    # Classification: String y vector notation
    # X <- c("ref","cocoa_per_int","rating")  # covariates/features
    X <- c("ref", "rating", "company_name_num", "origin_bar_num", "company_loc_num", "bean_origin_num")
    y <- 'bean_type_num ~ ' # response
    f <- as.formula(paste(y , paste(X, collapse='+')))
    print(f)
    model <- neuralnet(f, data=data_train, hidden = 3, learningrate=0.001,
                    act.fct = "logistic", linear.output = FALSE, lifesign = "minimal")
    # response = bean_type_num
    # covariate = ref cocoa_per_int rating
    # ..........
    data <- data_train
    y_actual <- y_train
    
} else if (laquelle == 4) {
    # Classification: DataFrame y vector notation
    y <- data_train$bean_type_num # response
    model <- neuralnet(y ~ ., data_train, hidden = 3, learningrate=0.01,
                    act.fct = "logistic", linear.output = FALSE, lifesign = "minimal")
    # response = y
    # covariate =  features (ref rating company_name_num origin_bar_num company_loc_num)
    # ..........
    data <- data_train
    y_actual <- y_train
    
} else {
    
}

# Confirm that the covariates and response are CORRECTLY assigned with the model print out
print(model)
```

    hidden: 3    thresh: 0.01    rep: 1/1    steps: 
         39
    	error: 1877.00631
    	time: 0.01 secs
    


    $call
    neuralnet(formula = y ~ ., data = data_train, hidden = 3, learningrate = 0.01, 
        lifesign = "minimal", act.fct = "logistic", linear.output = FALSE)
    
    $response
        y
        
    $covariate
        ref      rating company_name_num origin_bar_num company_loc_num bean_origin_num bean_type_num
        

    $model.list
    $model.list$response
    [1] "y"
    
    $model.list$variables
    [1] "ref"              "rating"           "company_name_num" "origin_bar_num"
    [5] "company_loc_num"  "bean_origin_num"  "bean_type_num"
    
    
    $err.fct
    function (x, y) 
    {
        1/2 * (y - x)^2
    }
    <bytecode: 0x557fcf52e9b0>
    <environment: 0x557fc988c1d8>
    attr(,"type")
    [1] "sse"
    
    $act.fct
    function (x) 
    {
        1/(1 + exp(-x))
    }
    <bytecode: 0x557fcf52a048>
    <environment: 0x557fc988bd40>
    attr(,"type")
    [1] "logistic"
    
    $linear.output
    [1] FALSE
    
    $data
                 ref      rating company_name_num origin_bar_num company_loc_num     bean_origin_num bean_type_num
                 
                 
    $weights
    $weights[[1]]
    $weights[[1]][[1]]
               [,1]       [,2]         [,3]
    [1,] 2.98432345  1.0440558  3.949354485
    [2,] 0.20539545 -1.6753731  0.225738628
    [3,] 0.28870154 -1.1334433  0.271566316
    [4,] 0.21703438 -0.7830075  0.230184640
    [5,] 0.05507391  0.8007502 -0.001791845
    [6,] 0.15834215 -0.6912414  0.127932698
    [7,] 0.13676624  1.0565532  0.094396875
    [8,] 2.95298291  0.2105750  2.665006283
    
    $weights[[1]][[2]]
             [,1]
    [1,] 3.236951
    [2,] 3.543837
    [3,] 2.130435
    [4,] 4.309714
    
    
    
    $generalized.weights
    $generalized.weights[[1]]
                 [,1]          [,2]          [,3]         [,4]          [,5]             [,6]         [,7]
    523 -2.545450e-01 -1.722072e-01 -1.189644e-01 1.216612e-01 -1.050224e-01            1.605268e-01 0.0320059396
    
    

    
    $startweights
    $startweights[[1]]
    $startweights[[1]][[1]]
                [,1]        [,2]       [,3]
    [1,] -0.08407655  0.77565581  0.1493545
    [2,] -0.35523945 -1.74377307 -1.2462614
    [3,] -0.44377558 -1.00184334  1.7399663
    [4,]  0.39185377  0.26227898 -0.4362154
    [5,]  0.97481903  0.10327910  0.6043551
    [6,]  0.75939335  0.43564196 -1.5404673
    [7,]  0.56779724  0.59956994 -0.3538031
    [8,] -0.11541709 -0.05782502 -1.1349937
    
    $startweights[[1]][[2]]
               [,1]
    [1,] -0.5630493
    [2,] -0.2561633
    [3,] -1.6695655
    [4,]  0.5097136
    
    
    
    $result.matrix
                                          [,1]
    error                         1.877006e+03
    reached.threshold             6.311835e-03
    steps                         3.900000e+01
    Intercept.to.1layhid1         2.984323e+00
    ref.to.1layhid1               2.053954e-01
    rating.to.1layhid1            2.887015e-01
    company_name_num.to.1layhid1  2.170344e-01
    origin_bar_num.to.1layhid1    5.507391e-02
    company_loc_num.to.1layhid1   1.583421e-01
    bean_origin_num.to.1layhid1   1.367662e-01
    bean_type_num.to.1layhid1     2.952983e+00
    Intercept.to.1layhid2         1.044056e+00
    ref.to.1layhid2              -1.675373e+00
    rating.to.1layhid2           -1.133443e+00
    company_name_num.to.1layhid2 -7.830075e-01
    origin_bar_num.to.1layhid2    8.007502e-01
    company_loc_num.to.1layhid2  -6.912414e-01
    bean_origin_num.to.1layhid2   1.056553e+00
    bean_type_num.to.1layhid2     2.105750e-01
    Intercept.to.1layhid3         3.949354e+00
    ref.to.1layhid3               2.257386e-01
    rating.to.1layhid3            2.715663e-01
    company_name_num.to.1layhid3  2.301846e-01
    origin_bar_num.to.1layhid3   -1.791845e-03
    company_loc_num.to.1layhid3   1.279327e-01
    bean_origin_num.to.1layhid3   9.439687e-02
    bean_type_num.to.1layhid3     2.665006e+00
    Intercept.to.y                3.236951e+00
    1layhid1.to.y                 3.543837e+00
    1layhid2.to.y                 2.130435e+00
    1layhid3.to.y                 4.309714e+00
    
    attr(,"class")
    [1] "nn"



```{r}
print('TRAINING accuracy:')
mydict <- model_pred_accuracy_NN(model, data, fst, fend, labnum)

print('mydict')
print(mydict)
```

    [1] "TRAINING accuracy:"
    [1] "Accuracy: (TP+TN)/(TP+TN+FP+FN)"
    [1] 0.04625199
    [1] "Accuracy: (TP+TN)/(TP+TN+FP+FN)"
    [1] "mydict"
     precision     recall        acc 
    0.04625199 1.00000000 0.04625199 



```{r}
# print('TEST accuracy:')
# mydict <- model_pred_accuracy_NN(model, data_test, fst, fend, labnum)

# print('mydict')
# print(mydict)
```

# RandomForest


```{r}
# Tilde symbol l is used within formulas of statistical models, 
# as mainly this symbol is used to define the relationship between 
# the dependent variable and the independent variables in the statistical 
# model formula in the R programming language. The left side of the tilde 
# symbol specifies the target variable (dependent variable or outcome) and 
# the right side of the tilde specifies the predictor variable(independent variables).

laquelle = 0

if (laquelle == 0){
    # Regression
    # X <- c("ref","cocoa_per_int","rating")  # covariates/features
    X <- c("ref","rating", "company_name_num", "origin_bar_num", "company_loc_num", "bean_origin_num")
    y <- 'bean_type_num ~ ' # response
    f <- as.formula(paste(y , paste(X, collapse='+')))
    print(f)
    model <- randomForest(f, data=data_train, importance=TRUE, proximity=TRUE)

} else if (laquelle == 1){
    # Regression
    model <- randomForest(y_train$bean_type_num ~., data=X_train, importance=TRUE, proximity=TRUE)
    
} else if (laquelle == 2){
    # Regression
    model <- randomForest(x=X_train, y=y_train$bean_type_num, 
                  xtest=X_test, ytest=y_test$bean_type_num, importance= TRUE)
} else {
    # Regression
    model <- randomForest(X_train, y_train$bean_type_num) 
}

print(model)
```

    bean_type_num ~ ref + rating + company_name_num + origin_bar_num + 
        company_loc_num + bean_origin_num


    Warning message in randomForest.default(m, y, ...):
    “The response has five or fewer unique values.  Are you sure you want to do regression?”


    
    Call:
     randomForest(formula = f, data = data_train, importance = TRUE,      proximity = TRUE) 
                   Type of random forest: regression
                         Number of trees: 500
    No. of variables tried at each split: 2
    
              Mean of squared residuals: 0.4868278
                        % Var explained: 42.3



```{r}
print('TRAINING accuracy:')
mydict <- model_pred_accuracy_RF(model, data, fst, fend, labnum)
print('mydict')
print(mydict)
```

    [1] "TRAINING accuracy:"
[1] "mydict"
precision    recall       acc 
0.8803828 1.0000000 0.8803828


```{r}
# print('------------------------------------------------------')
# print('TEST accuracy:')
# mydict <- model_pred_accuracy_RF(model, data_test, fst, fend, labnum)
# print('mydict')
# print(mydict)
```


```{r}
print('------------------------------------------------------')
print('Evaluate Feature Importance:')
round(importance(model), 2)
```

[1] "------------------------------------------------------"
[1] "Evaluate Feature Importance:"

A matrix: 6 × 2 of type dbl 	%IncMSE	IncNodePurity
ref	30.46	91.05
rating	1.37	29.70
company_name_num	11.75	57.13
origin_bar_num	32.85	112.55
company_loc_num	20.76	43.43
bean_origin_num	51.95	150.02

